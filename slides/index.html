<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">
<!--
  <slide class="logoslide nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/google_developers_logo.png"></span>
    </article>
  </slide>
-->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
  
  <!-- what's android after all -->
  <!-- componenti del framework -->
  <!-- tools intro -->

  <slide>
    <hgroup>
      <h2>Obiettivi</h2>
    </hgroup>
    <article class="flexbox vcenter" >
      <ol class="build fade">
      <li><p>
	  Imparare l'architettura, le API, e i tool di sviluppo su Android.
      </p></li>
      <li><p>
	Acquisire pattern di programmazione adatti a dispositivi resource constrained in java.
      </p></li>
      </ol>
    </article>
  </slide>

  <slide>
    <hgroup><h2>Materiale</h2></hgroup>
    <article>
      <ul>
	<li>Codice <a href="https://github.com/eliantor/Course2014Bari">&lt;https://github.com/eliantor/Course2014Bari&gt;</a></li>
	<!--<li>Groups <a href="https://groups.google.com/forum/#!forum/androidcourses">&lt;https://groups.google.com/forum/#!forum/androidcourses&gt;</a></li>-->
  <li>Slide <a href="http://eliantor.github.io/AndroidCourse">&lt;http://eliantor.github.io/AndroidCourse&gt;</a></li>
	<li>Riferimenti, libri, link contenuti video ecc</li>
      </ul>
      
    </article>
  </slide>
  
  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Prima lezione</h2>
      <h3>Android OS Introduzione al framework</h3>
    </hgroup>
  </slide>

<!--
  <slide>
    <hgroup><h2>Storia</h2></hgroup>
    <article>
      <ul class="build">
	<li><span class="blue3">2003</span> Nasce il progetto da Android Inc. fondata da Andy Rubin e Rich Miner</li>
	<li><span class="blue3">2005</span> Acquisizione Google </li>
	<li><span class="blue3">2007</span> Open Handset Alliance</li>
	<li><span class="blue3">2008</span> HTC Dream (T Mobile G1) rilasciato il 22 ottobre</li>
	<li><span class="blue3">2009</span> 2.8% del market share</li>
	<li><span class="blue3">2011</span> +4.4% di crescita per settimana</li>
	<li><span class="blue3">2013</span> 64% del mercato mobile</li>
	<li><span class="blue3">2013+</span> Android Everywhere: GoogleTV, Project Glass, Media players, Android@Home, Project Shield...</li>  
      </ul>
    </article>
  </slide>
   <slide class="fill nobackground" style="background-image: url(images/amirror.jpg)">
    <hgroup>
      <h2 class="white">SPECCHI!!</h2>
    </hgroup>
    <footer class="source black">www.cybertecturemirror.com</footer>
  </slide>

  <slide class="fill nobackground" style="background-image: url(images/andy-rubin.png)">
    <hgroup>
      <h2 class="white">...e fotocamere</h2>
    </hgroup>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <img src="images/dslr.jpg"/>
    <footer class="source white">Andy Rubin</footer>
  </slide>
-->
  <slide>
    <hgroup>
      <h2>Mindset</h2>
      <h3>Di cosa devo tener conto quando scrivo un'app android</h3>
    </hgroup>
    <article>
      <ul class="build" style="list-style-type:none">
	<li><ul>
	<li class="green3">Intero sistema operativo a disposizione (Api potenti)</li>
	<li class="green3">Tutte le app sono create uguali</li>
	<li class="green3">App come servizi integrati</li>
	<li class="green3">Applicazioni event driven e context based (gps, sensori, touch,audio,camera)</li>
	<li class="green3">Varietà di scelta dei dispositivi</li>
	</ul></li>
	<li><ul>
	<li class="red3">Risorse limitate (memoria, batteria, banda)</li>
	<li class="red3">Use cases complessi, le app non hanno un main</li>
	<li class="red3">Callback hell</li>
	<li class="red3">Frammentazione del mercato</li>
      </ul></li>
      </ul>
    </article>
  </slide>
  
  <slide>
    <hgroup>
      <h2>Architettura</h2>
    </hgroup>
    <article class="columns-2">
     <div>
      <ul class="build">
	<li>Linux (Experimental branch start merge mainline 3.8)</li>
	<li>Binder IPC (driver al cuore del funzionamento di android)</li>
	<li>Dalvik (vm a registri che esegue dex bytecode)/ ART</li>
	<li>System Services (WindowManager, Audio, Networking, Telephony ...)</li>
	<li>SDK libs (le API a nostra disposizione)</li>
	<li>Java (versione 6/7)</li>
      </ul>
      </div>
      <div><img src="images/system_architecture1.png"/></div>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Building blocks</h2>
      <h3>intro</h3>
    </hgroup>
    <article class="flexbox vcenter build fade">
      <p>Un'app android é costituita da <span class="red3">componenti</span> attivi (lousely coupled) e da un insieme di <span class="red3">risorse</span>.<br/>Questi pezzi disaccoppiati sono uniti insieme a runtime in un'unica <span class="red3">Application (Context)</span> da un file di configurazione <span class="red3">manifest</span>.
      </p>
      <p>Una caratteristica fondamentale di Android é che un app puó attivare direttamente un componente di un'altra applicazione, inviando messaggi <span class="red3">intent</span> o richiamando specifiche <span class="red3">uri</span>. Il manifest specifica quali messaggi un componente é in grado di ricevere tramite specifici <span class="red3">filtri</span>.</p>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Building blocks</h2>
      <h3>components</h3>
    </hgroup>
    <article class="flexbox vcenter">
      <img src="images/app_components.png"/>
    </article>
  </slide>
  

  <slide>
    <hgroup>
      <h2>App basics</h2>
      <h3>Organizzazione</h3>
    </hgroup>
    <article class="build fade smaller">
      <section>
          <p>Organizzazione del codice in classico stile maven</p>
        <ul>
          <li>src/main/java (contiene il codice dell'applicazione)</li>
          <li>src/main/res (contiene le risorse dell'app)</li>
          <li>src/main/assets (file system interno readonly)</li>
          <li>src/main/AndroidManifest.xml (il manifest dell'app)</li>
        </ul>
      </section>
      <section>
        <pre class="prettyprint" data-lang="xml">
        &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
          <b>package="corso.sample"</b>
          android:versionCode="1"
          android:versionName="1.0" &gt;
          &lt;uses-sdk
            android:minSdkVersion="9"
            android:targetSdkVersion="19"/&gt;
          <b>&lt;application
            android:icon="@drawable/ic_launcher"
            android:label="@string/app_name"&gt;
          &lt;/application&gt;</b>
        &lt;/manifest&gt;</pre>
      </section>
    </article>
  </slide>

  <slide class="segue fill nobackground" style="background-image: url(images/tooling.jpg)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">TOOLING</h2>
    </hgroup>
  </slide>

  <slide>
      <hgroup>
          <h2>Gradle/AndroidStudio</h2>
      </hgroup>
      <article>
          <ul>
              <li>Risolve il problema ADT/ANT duality</li>
              <li>Funziona da riga di comando</li>
              <li>Semplifica il lavoro in team</li>
              <li>Permette automazione ed integrazione con IDE</li>
          </ul>
      </article>
  </slide>

  <slide>
    <hgroup><h2>Gradle</h2></hgroup>
    <article>
        <ul>
            <li>Basato su groovy</li>
            <li>Rimpiazza ANT/MAVEN</li>
            <li>Gestisce le dipendeze come MAVEN</li>
            <li>Ha task customizzabili come ANT</li>
            <li>DSL per la generazione di build script (no XMLHELL)</li>
            <li>Bootstrap automatico del progetto</li>
            <li>Plugin based</li>
        </ul>
    </article>
  </slide>


<slide>
    <hgroup><h2>Gradle Android Plugin</h2></hgroup>
    <article>
        <h3>Feature interessanti</h3>
        <ul>
            <li>Testing integrato in un unico proggetto</li>
            <li>Multiproject setup (piú app/librerie) nello stesso progetto</li>
            <li>Build type multipli debug/release/(your special case)</li>
            <li>Flavors free/paid/premium</li>
        </ul>
    </article>
</slide>

<slide>
<hgroup><h2>Gradle Project</h2></hgroup>
    <article class="smaller">
        <p>Sample build script</p>
        <pre class="prettyprint" data-lang="groovy">
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.9.1'
    }
}
apply plugin: 'android'
repositories {
    mavenCentral()
}
android {
    compileSdkVersion 19
    buildToolsVersion "19.0.3"
    //...
}
dependencies {
    compile 'com.android.support:support-v4:19.0.1'
}</pre>
    </article>
</slide>
  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="blue3">Activity</h2>
    </hgroup>
  </slide>

  <slide>
    <hgroup>
      <h2>Activity</h2>
      <h3>intro</h3>
    </hgroup>
    <article>
      <p>
      Un'activity rappresenta una schermata (di solito copre l'intera finestra) con cui l'utente puó interagire per
      realizzare un'azione.
      </p>
      <ul class="build">
        <li>Pattern MVC</li>
        <li>Attivata da un'intent</li>
        <li>Ha un layout (vista), tipicamente associato tramite una risorsa xml</li>
        <li>Puó far partire altre activity</li>
        <li>Piú activity costituiscono un task</li>
        <li>Ciclo di vita gestito dal sistema</li>
        <li>Puó contenere fragments e loaders</li>
      </ul>
    </article>
  </slide>
  
  <slide >
    <hgroup>
      <h2>Activity</h2>
      <h3>lifecycle</h3>
    </hgroup>
    <article class="columns-2">
      <img src="images/activity_lifecycle.png"/>
      <ul class="build">
        <li>Un'activity puó essere distrutta dal sistema per recuperare memoria</li>
        <li>L'intero processo dell'applicazione puó essere terminato dopo <span class="red3">onPause()</span></li>
        <li>Un'activity puó attraversare diverse volte i metodi tra <span class="red3">onCreate()</span> e <span class="red3">onDestroy()</span> nel suo ciclo di vita</li>
        <li>Dobbiamo preoccuparci di rilasciare le risorse durante i metodi di terminazione</li>
        <li>Attenzione ai memory leak! (vedremo esempi)</li>
       </ul>
    </article>
  </slide>


  <slide>
    <hgroup>
      <h2>Activity </h2>
      <h3>code</h3>
    </hgroup>
    <article class="smaller">
    <pre class="prettyprint" data-lang="java">
      package com.corso.sample.activity;
      import com.corso.sample.R;
      import android.app.Activity;
      
      <b>public class ExampleActivity extends Activity {</b>
        @Override
        public void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          // The activity is being created.
          setContentView(R.layout.my_layout);
        }
      <b>}</b></pre>
    <pre class="prettyprint" data-lang="xml">
      &lt;application&gt;
        <b>&lt;activity android:name=".activity.ExampleActivity"</b>
            android:label="@string/app_name"
            android:icon="@drawable/ic_launcher"<b>&gt;</b>
            &lt;!-- ..... --&gt;
        <b>&lt;/activity&gt;</b>
      &lt;/application&gt;</pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Activity </h2>
      <h3>more code</h3>
    </hgroup>
    <article class="smaller">
      <section>
      <pre class="prettyprint" data-lang="xml"><b>
      &lt;?xml version="1.0" encoding="utf-8"?&gt;
      &lt;!-- res/layout/mylayout.xml --&gt;
      &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"&gt;
        &lt;TextView 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/hello"/&gt;
      &lt;/LinearLayout&gt;</b></pre>
      <pre class="prettyprint" data-lang="xml">
      &lt;resources&gt;
        &lt;string name="app_name"&gt;Sample&lt;/string&gt;
        &lt;string name="hello"&gt;Hello world!/string&gt;
      &lt;/resources&gt;</pre>
      </section>
    </article>
  </slide>

  <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">CODE</h2>
    </hgroup>
  </slide>

  <slide >
    <hgroup>
      <h2>Wiews</h2>
      <h3>Gestire l'interfaccia</h3>
    </hgroup>
    <article class="smaller">
      <section>
        <p>Dobbiamo poter recuperare le viste nel codice</p>
        <pre class="prettyprint" data-lang="xml">
          &lt;TextView 
            <b>android:id="@+id/tv_hello"</b>
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/hello"/&gt;
        </pre>
        <pre class="prettyprint" data-lang="java">
          <b>TextView mHello;</b>
          @Override
          public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.my_layout);
            <b>mHelloOut = (TextView)findViewById(R.id.tv_hello);</b>
          }
        </pre>
      </section>
    </article>
  </slide>

   <slide >
    <hgroup>
      <h2>Wiews</h2>
      <h3>Gestire l'interfaccia</h3>
    </hgroup>
    <article class="smaller">
      <section>
        <p>Alcune viste hanno associato un comportamento</p>
        <pre class="prettyprint" data-lang="java">
          View mInteractive;

          @Override
          public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.my_layout);
            mInteractive = findViewById(R.id.btn);
            <b>mInteractive.setOnClickListener(new OnClickListener{
              @Override
              public void onClick(View v){
                //do something
              }
            });</b>
          }
        </pre>
      </section>
    </article>
  </slide>

  <slide >
    <hgroup>
      <h2>Wiews</h2>
      <h3>Gestire l'interfaccia</h3>
    </hgroup>
    <article class="smaller">
      <section>
        <p>Alcune viste contengono dati</p>
        <pre class="prettyprint" data-lang="java">
          //....
          @Override
          public void onCreate(Bundle savedInstanceState) {
            //....
            mInteractive = (EditText)findViewById(R.id.btn);
            mReplaceButton.setOnClickListener(this);
          }
          @Override
          public void onClick(View v){
            if(v.getId()==mReplaceButton.getId()){
              mSavedContent = replaceContent(mSavedContent);
            }
          }
          //...
          <b>
          private String replaceContent(String content){
            Editable content =mInteractive.getText();
            mInteractive.setText(content);
            return content.toString();
          }</b>
        </pre>
      </section>
    </article>
  </slide>

  <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">CODE</h2>
    </hgroup>
  </slide>


  <slide>
    <hgroup><h2>Activity</h2>
    <h3>Mantenere lo stato</h3>
    </hgroup>
      <article class="smaller">
      <p>Il sistema operativo puó interrompere il nostro processo</p>
      <br/>
      <section class="build">
      <ul>
      <li>
        Per recuperare memoria o durante un cambio di configurazione (Es. rotazione dello schermo)
      </li>
      <li>Dobbiamo salvare lo stato in modo persistente, (il processo viene deallocato)</li>

      </ul>
      <pre class="prettyprint" data-lang="java">
          <b>private final static String SAVED_KEY="SAVED_KEY";
          @Override
          public void onCreate(Bundle savedInstanceState) {
            if(savedInstanceState!=null){
              //activity restarted
              mState =  savedInstanceState.getBoolean(SAVED_KEY);
            }else{
              mState = initializeState();
            }
          }</b>
          @Override
          protected void onRestoreInstanceState(Bundle savedInstanceState){/*or here after onStart()*/}
          <b>@Override
          protected void onSaveInstanceState(Bundle outState){
            outState.putBoolean(SAVED_KEY,mState)
          }</b></pre>
      </section>
      </article>
  </slide>
  <slide>
    <hgroup><h2>Activity</h2>
    <h3>Navigazione</h3>
    </hgroup>
    <article class="flexbox vcenter">
      <ul class="build">
        <li>Creare link tra activity</li>
        <li>Delegare l'esecuzione di un task ad un'altra activity e riceverne il risultato</li>
        <li>Ricordiamo che la comunicazione avviene sempre tramite intent</li>
      </ul>
    </article>
  </slide>

  <slide>
    <hgroup><h2>Activity</h2>
    <h3>Navigazione 2</h3>
    </hgroup>
    <article class="build fade smaller">
        <section>
          <p>Creare link tra activity</p>
          <pre class="prettyprint" data-lang="java">
            private void launch(boolean explicit){
              final Intent intent;
              if(explicit){
                intent = new Intent(this,AnotherActivityInMyPackage.class);
              }else{
                intent = new Intent("an.explicit.action");
              }
              intent.setData(Uri.parse("mydata://somedata/1000"));
              intent.putExtra("A_KEY",1000);
              this.startActivity(intent);
            }</pre>
        </section>
        <section>
          <p>Delegare l'esecuzione di un task</p>
          <pre class="prettyprint" data-lang="java">
            private final static int MY_REQUEST_CODE = 1;
            //...
            this.startActivityForResult(intent,MY_REQUEST_CODE);</pre>
        </section>
    </article>
  </slide>

  <slide>
    <hgroup><h2>Activity</h2>
    <h3>Navigazione 3</h3>
    </hgroup>
    <article class="build fade smaller">
        <section>
          <p>Creare link tra activity</p>
          <pre class="prettyprint" data-lang="java">
            @Override
            public void onCreate(Bundle savedInstanceState){
                handle(getIntent());
            }
            @Override
            protected void onNewIntent(Intent intent){
                setIntent(intent); //Optionally
                handle(intent);
            }
            private void handle(Intent intent){}</pre>
        </section>
        <section>
          <p>Delegare l'esecuzione di un task</p>
          <pre class="prettyprint" data-lang="java">
             setResult(RESULT_OK,new Intent().putExtra("content",response));
             //data is optional
             //setResult(int x); RESULT_OK RESULT_CANCELED RESULT_FIRS_USER
             finish();</pre>
        </section>
    </article>
  </slide>

  <slide>
    <hgroup><h2>Activity</h2>
    <h3>Navigazione 4</h3>
    </hgroup>
    <article class="smaller">
      <p>Ricevere il risultato</p>
      <pre class="prettyprint" data-lang="java">
        private final static int MY_REQUEST_CODE = 1;
        //...
        @Override
        protected void onActivityResult (int requestCode, int resultCode, Intent data){
          if(requestCode==MY_REQUEST_CODE){
            if(resultCode==RESULT_OK){
              //do something with data may be null
            }else{
              //do something when user refused to complete action
            }
          }else{
            // not my business another request
          }
        }</pre>
    </article>
  </slide>

  <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">CODE</h2>
    </hgroup>
  </slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Parte 2</h2>
        <h3>UI</h3>
    </hgroup>
</slide>
  <slide>
      <hgroup>
          <h2>Risorse</h2>
          <h3>Introduzione</h3>
      </hgroup>
      <article>
          <ul class="build">
              <li>Android tiene separate strettamente le view dal controller</li>
              <li>Le viste sono definite come risorse (file xml)</li>
              <li>Testo e immagini sono in risorse separate</li>
              <li>Binding dinamico delle risorse a runtime</li>
              <li>La risoluzione della risorsa si basa sul matching tra <span class="red">qualificatori</span> e <span class="red">configurazione</span> del device</li>
              <li>Esempi di qualificatori
                <ol>
                    <li>Versione del SO</li>
                    <li>Locale</li>
                    <li>dimensione dello schermo</li>
                    <li>orientamento dello schermo</li>
                </ol>
              </li>
          </ul>
      </article>
  </slide>

  <slide>
      <hgroup><h2>Risorse</h2>
      <h3>Values</h3></hgroup>
      <article>
          <ul>
              <li>Risorse scalari il cui valore é determinato dinamicamente</li>
              <li>Definite nelle cartelle values-*</li>
              <li>Stringhe (utile per l'internazionalizzazione)</li>
              <li>Dimensioni definite in <span class="red">DP SP</span> density independent pixels*</li>
              <li>Id costanti compile time univoche generate dal sistema</li>
          </ul>
      </article>
  </slide>
<slide>
    <hgroup><h2>Risorse</h2>
    <h3>Layout</h3></hgroup>
    <article>
        <ul class="build">
            <li>Risorse che definiscono le viste</li>
            <li>Vengono espanse a runtime in un albero di View (simile al DOM)</li>
            <li>I nodi interni sono ViewGroup (possono contenere altri nodi)</li>
            <li>I nodi foglia sono View (icone/bottoni/campi di testo)</li>
            <li>Alcune view sono collegate dinamicamente ai dati (liste/griglie/pager)</li>
            <li>Vediamo esempio di layout e gestione della compatibilitá tra schermi</li>
        </ul>
</article>
</slide>
    <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
        <hgroup class="auto-fadein">
            <h2 class="white">CODE</h2>
        </hgroup>
    </slide>

</slide>
  <slide >
    <hgroup>
      <h2>AdapterViews</h2>
      <h3>Gestire interfacce dinamiche</h3>
    </hgroup>
    <article class="build">
      <section><p>Alcune viste sono collegate a modelli complessi:<br/> collection di un numero variabile di item, che a loro volta sono rappresentati da specifici insiemi di viste.
      </p></section>
      <section>
        <ul>
        <li>Gestione e visualizzazione del modello globale</li>
        <li>Numero di item</li>
        <li>Accesso al singolo item</li>
        <li>Generazione della vista per lo specifico item</li>
        </ul>
      </section>
      <section>
        <p>Serve un ulteriore livello di indirezione:<br/>
          introduciamo gli Adapter.
        </p>
      </section>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>AdapterViews</h2>
      <h3>Code</h3>
    </hgroup>
    <article class="smaller build fade">
      <pre class="prettyprint" data-lang="java">
        public class MyAdapter extends BaseAdapter{
          private final LayoutInflater mInflaterService;
        //...
          @Override
          public View getView(int position,View convertView,View theList){
            <b>View v = mInflaterService.inflate(R.layout.item_layout,theList,false);</b>
            presentTheItem(<b>getItem(position)</b>);
            return v;
          }
        }</pre>
        <pre class="prettyprint" data-lang="java">
        ListView lv = findViewById(R.id.list);
        mAdapter = new MyAdapter((Context)this);
        lv.setAdapter(adapter);
        lv.setOnItemClickListener(/*the listener*/);</pre>
        <pre class="prettyprint" data-lang="java">
        private void updateData(){
          doUpdtateData();
          mAdapter.notifyDataSetChanged();
        }</pre>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>AdapterViews</h2>
      <h3>Note</h3>
    </hgroup>
    <article>
    <ul class="build">
      <li>Gli item possono essere associati a viste diverse</li>
      <li>getView() viene chiamato per ogni item</li>
      <li>getView() espande un nuovo layout per ogni item</li>
      <li>spesso questa operazione é ridondante</li>
      <li>solo una piccola porzione degli item é visibile sullo schermo</li>
      <li>ViewHolder pattern o sottoclassi specifiche di Adapter</li>
    </ul>
    </article>
  </slide>

  <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">CODE</h2>
    </hgroup>
  </slide>

  <slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Parte 3</h2>
      <h3>Fragments</h3>
    </hgroup>
  </slide>
  
  <slide>
  	<hgroup><h2>Fragments</h2>
  		<h3>Introduzione</h3>
  	</hgroup>
  	<article>
  		<ul>
  			<li>Introdotti in android 3.0 per supportare i tablet</li>
  			<li>Decompongono un'activity in sottocomponenti</li>
  			<li>Facilitano il riutilizzo del codice</li>
  			<li>NON sono componenti di Android nel senso classico ma classi di supporto del framework</li>
  			<li>Possono essere usati su versioni piú vecchie tramite libreria statica di supporto</li>
            <li>Strumento duale rispetto al late-bindining delle risorse per la cross compatibily</li>
  		</ul>
  	</article>
  </slide>
  
  <slide>
  	<hgroup><h2>Fragments</h2>
  		<h3>Introduzione 2</h3>
  	</hgroup>
  	<article class="columns-2">
  	  <img src="images/fragment_lifecycle.png"/>
	  <ul class="build">
  	  <li>Ciclo di vita piú complesso di quello di un'activity</li>
	  <li>Un fragment puo' non avere un'interfaccia grafica associata</li>
	  <li>Un fragment puo essere aggiunto e rimosso dinamicamente</li>
	  <li>Solo da 1 versione un fragment puo' contenere altri fragment</li> 
  	</ul>
  	</article>
  </slide>
  <slide>
    <hgroup>
      <h2>Fragments</h2>
      <h3>Code</h3>
    </hgroup>
    <article class="smaller">
      <pre class="prettyprint" data-lang="java">
	public class MyFragment extends Fragment {
	  @Override
          public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
            View v = inflater.inflate(R.layout.my_fragment,container,false);
	    // ... setup
	    return v;
	  }
	
	  @Override
	  public void onActivityCreated(Bundle savedInstanceState){
            // ...
          }
          // ...
	}
</pre>
    <pre class="prettyprint" data-lang="xml">
     &lt;!-- in the layout for the activity --&gt;
     &lt;!-- .... --&gt;
     &lt;fragment class="com.example.MyFragment"
               android:id="@+id/MyFragmentId"
               android:layout_width="match_parent"
               android:layout_height="wrap_content"/&gt;
   </pre>
    </article>
  </slide>
<slide>
    <hgroup>
        <h2>Fragments</h2>
        <h3>Code</h3>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
            public class MyActivity extends FragmentActivity{
                @Override
                public void onCreate(Bundle savedInstanceState){
                    setContentView(R.layout.my_activity);
                    //...
                   <b> FragmentManager manager = getSupportFragmentManager();
                    MyFragment f = (MyFragment)manager.findFragmentById(R.id.MyFragmentId);
                   </b>
                }
            }</pre>
    </article>
</slide>
   <slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
        <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
      <h2 class="white">CODE</h2>
    </hgroup>
  </slide>

<slide>
    <hgroup><h2>Fragment Dinamici</h2>
        <h3>Introduzione</h3>
    </hgroup>
    <article class="smaller">
        <ul class="build">
            <li>I fragment possono non essere dichiarati staticamente nei layout</li>
            <li>In questo caso possono non avere una vista associata</li>
            <li><pre class="prettyprint" data-lang="java">
                // in the activity

                private final static String TRANSACTION_TAG = "A TAG";

                //...

                MyFragment f = new MyFragment();

                FragmentManager m = getSupportFragmentManager();
                m.beginTransaction()
                 .replace(R.id.viewgroup,f,TRANSACTION_TAG)
                 .addToBackStack(null)
                 .commit();

                //..

                m.findFragmentByTag(TRANSACTION_TAG);</pre> </li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup><h2>Fragment</h2>
        <h3>... non finisce qui</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>I fragment si rivelano utili in molte situazioni, diverse da quelle per
            cui
            sono stati progettati.</li>
        <li>Possiamo separare il ciclo di vita da quello dell'activity
            <pre class="prettyprint" data-lang="java">setRetainInstance(true);</pre></li>
            <li>Utile per salvare stato dell'applicazione complesso
                <b>Fragment Memory Card</b></li>
            <li>Utile supporto per la concorrenza: fa da bridge con altri thread.</li>
        </ul>
    </article>
</slide>

<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Seconda lezione</h2>
        <h3>Persistenza</h3>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Persistenza</h2>
        <h3>Alternative</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>File system</li>
            <li>Preferenze</li>
            <li>Database</li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Persistenza</h2>
        <h3>File system</h3>
    </hgroup>
    <article class="smaller">
        <ul class="build">
            <li><p>Internal private storage</p>
            <pre class="prettyprint" data-lang="java">
                String FILENAME = "myprivatefile";
                FileInputStream in =context.openFileInput(FILENAME,Context.MODE_PRIVATE);
                //...
                FileOutputStream out = context.openFileOutput(FILENAME,Context.MODE_PRIVATE);</pre>
            </li>
            <li><p>Caching</p>
            <pre class="prettyprint" data-lang="java">
                File f =context.getCacheDir(); // i file possono essere rimossi dal sistema</pre> </li>
            <li><p>External storage</p>
                <pre class="prettyprint" data-lang="java">
                    // controllare se abbiamo un sd
                    Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);
                    // aprire la nostra root sull'sd esterna
                    File f =Environment.getExternalFilesDir(); // /Android/data/mio.package/files/
                    File f =Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC); //shared</pre>
            </li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Persistenza</h2>
        <h3>Preferences</h3>
    </hgroup>
    <article class="smaller build">
        <p>Specifiche per activity o globali (con nome)</p>
        <p>Salvate come file xml nello storage interno</p>
        <pre class="prettyprint" data-lang="java">
            SharedPreferences localPrefs = activity.getPreferences();

            SharedPreferences prefs = context.getSharedPreferences("PREFS_FILE",MODE_PRIVATE);
            boolean myOptionalPref = context.getBoolean("onOffPreference",/*default*/false);
            String myOptionalText = context.getString("textPreference",/*default*/"fallback");
            //...
            SharedPreferences.Editor editor = prefs.edit();
            editor.putBoolean("key",false)
                  .putInt("intKey",69)
                  .commit():
        </pre>
    </article>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Seconda lezione</h2>
        <h3>Database</h3>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Database</h2>
        <h3>SQLite</h3>
    </hgroup>
    <article>
        <p>SQLite é un database embedded (nessuna connessione tramite jdbc) gira nel nostro
            stesso processo </p>
        <p>Non ha tutte le funzionalitá di un database full fledged</p>
        <p>Il db é un singolo file</p>
        <p>Non é tipizzato: una colonna puó contenere qualsiasi tipo</p>
        <p>Manca di alcune features importanti come gli outer join e i foreign constraints
            sono disabilitati di default</p>
        <p>Pessima concorrenza</p>
        <p>Nonostante tutto ottimo per applicazioni embedded</p>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Database</h2>
        <h3>SQLite</h3>
    </hgroup>
    <article class="smaller">
        <p>Creiamo un db tramite SQliteOpenHelper</p>
        <pre class="prettyprint" data-lang="java">
            public class TodoOpenHelper extends SqliteOpenHelper{
               TodoOpenHelper(Context context){
                    super(context,DATABASE_FILE,/*CursorFactory*/null,DATABASE_INT_VERSION);
               }

               public void onCreate(SQLiteDatabase db) {
                 db.execSql(CREATE_TABLE_SQL);
               }

               public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion) {
                 db.execSql(ALTER_TABLE_SQL);
               }
                //....
            }
        </pre>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Database</h2>
        <h3>Interazione</h3>
    </hgroup>
    <article class="smaller">
    <pre class="prettyprint" data-lang="java">
        TodoHelper helper = ...;
        SQLiteDatabase db =helper.getWritableDatabase();

        ContentValues values = new ContentValues(); // riga da inserire
        long newid=db.insert("table_name",null,values);
        int numUpdates=db.update("table_name",null,values,"_id = ?",new String[]{"1"});
        int numDeletes=db.delete("table_name","_id = ?",new String[]{"2"});
        Cursor cursor =db.query("table_name",
                                new String[]{"_id","text"},"_id = ?",new String[]{"3"},
                                /*groupby*/null,/*having*/null,/*orderby*/null,/*limit*/null);

        int count = cursor.getCount();
        if(cursor.moveToFirst()){
            String name = cursor.getString(cursor.getColumnIndexOrThrow("name"));
        }

        cursor.close();
    </pre>
    </article>
    </slide>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Seconda lezione</h2>
        <h3>Content Providers</h3>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>ContentProviders</h2>
        <h3>Introduzione</h3>
    </hgroup>
    <article class="build">
        <p>developers.android.com dice "you don't need content providers if you don't want to
            share content with other apps but..."</p>
        <ul class="build">
            <li>Vi serve se volete implemetare facilmente search e suggerimenti</li>
            <li>Vi serve se volete implementare il drag & drop con le altre app</li>
            <li>Vi serve se volete sfruttare al meglio gli altri componenti del
                framework</li>
            <li>Vi serve se volete sincronizzare i dati in modo facile con la rete</li>
            <li><span class="red">Vi serve se volete strutturare bene un app</span></li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup><h2>Content Providers</h2>
        <h3>Elementi essenziali</h3>
    </hgroup>
    <article class="build">
        <p>I content provider implementano un'architettura client/server</p>
        <p>Client: ContentResolver <-> Server: ContentProvider</p>
        <p>Un CP risponde ad una o piú <span class="blue">AUTHORITY</span> </p>
        <p>Si comunica con un CP tramite uri nella forma <b>content://authority/path</b></p>
        <p>I CP possono implementare schemi complessi di permessi</p>
        <p>API ottimizzata per dati tabulari (SQL) o file, ma nessun altro enforcement per il
            backend</p>
        <p>Possono auto sincronizzarsi con la rete</p>
        <p>Consentono di creare ui reattive</p>
    </article>
</slide>

<slide>
    <hgroup><h2>Content Providers</h2>
        <h3>Api client side</h3>
    </hgroup>
    <article class="smaller build">
        <pre class="prettyprint" data-lang="java">
            // lato client stessa api di sqlite con in piú l'uri
            ContentResolver resolver =context.getContentResolver();
            Cursor cursor =resolver.query(uri,projection,selection,selectionArgs,null,null,null);
            // o per l'apertura di file
            InputStream input =resolve.openInputStream(uri);</pre>
        <pre class="prettyprint" data-lang="java">
            // il content provider
            public class TodoProvider extends ContentProvider{
                public boolean onCreate(){}

                public Cursor query(Uri uri,String[] projection,String selection,...);
                public Uri insert(Uri uri,ContentValues values);
                public int delete(Uri,...);
                public int update(Uri uri,...);
                public String getType(Uri uri);
                public ParcelFileDescriptor openFile(Uri uri,String mode);
            }</pre>
        <pre class="prettyprint" data-lang="xml">
            &lt;!--nel manifest--&gt;
            &lt;provider android:authorities="com.jdk.todo.provider"
                         android:readPermission="com.jdk.permissions.READ_TODO"
                         android:writePermission="com.jdk.permissions.WRITE_TODO"&gt;>
            &lt;/provider&gt;
        </pre>
    </article>
</slide>

<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Terza lezione</h2>
        <h3>Concorrenza</h3>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Necessaria...</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>L'event loop principale deve essere libero da operazioni costose</li>
            <li>Le operazioni di I/O bloccano il thread su cui vengono eseguite</li>
            <li>In particolare l'accesso alla rete</li>
            <li>Android su questo é molto severo:</li>
            <li><article class="smaller">
                <pre class="prettyprint" data-lang="java">05-14 23:52:47.258:
                    E/AndroidRuntime(21329): <b>FATAL EXCEPTION</b>: main
05-14 23:52:47.258: E/AndroidRuntime(21329): <b>android.os.NetworkOnMainThreadException</b>
05-14 23:52:47.258: E/AndroidRuntime(21329):    at
                    android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1126)
05-14 23:52:47.258: E/AndroidRuntime(21329):    at
                    java.net.InetAddress.lookupHostByName(InetAddress.java:385)
05-14 23:52:47.258: E/AndroidRuntime(21329):    at
                    java.net.InetAddress.getAllByNameImpl(InetAddress.java:236)
05-14 23:52:47.258: E/AndroidRuntime(21329):    at
                    java.net.InetAddress.getAllByName(InetAddress.java:214)
05-14 23:52:47.258: E/AndroidRuntime(21329):    at
                    libcore.net.http.HttpConnection.&lt;init&gt;(HttpConnection.java:70)
                    ....
</pre></article></li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
    </hgroup>
    <article class="flexbox vcenter">
        <img src="images/concurrency.jpg"/>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Componenti essenziali</h3>
    </hgroup>
    <article class="build">
        <p>L'unitá di concorrenza in java é il Thread</p>
        <p>Ogni thread esegue un path di esecuzione indipendente. In modo concorrente,
            (realmente concorrente se siamo su un multi core)</p>
        <p>Un Thread é anche una radice per quanto concerne il garbage collector, la concorrenza é
           la causa dei memory leak</p>
        <p>I thread hanno bisogno di comunicare tra loro e sincronizzarsi</p>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Threads</h3>
    </hgroup>
    <article>

    <p>Uso diretto dei thread</p>
    <ul class="build">
        <li class="green">Completa gestione del multithreading</li>
        <li class="red">Non gestiscono il ciclo di vita dei componenti android</li>
        <li class="red">Non facilitano update della ui</li>
    </ul>

    </article>
</slide>
<slide>
    <hgroup>
        <h2>Threads</h2>
        <h3>Quando usarli</h3>
    </hgroup>
    <article>
        <ul>
            <li>Necessitiamo un controllo diretto e preciso del multithreading</li>
            <li>Conosciamo esattamente il comportamento della concorrenza nella nostra
                applicazione</li>
            <li>Sappiamo come sincronizzarli e metterli in comunicazione, (lock, semafori,
                mutex, atomic CAS)</li>
        </ul>
    </article>
</slide>

<slide class="fill nobackground" style="background-image: url(images/locks.jpg)">
    <hgroup>
        <h2 class="white">...ad esempio...</h2>
    </hgroup>
</slide>

<slide class="fill nobackground" style="background-image: url(images/semaphores.jpg)">

</slide>
<slide class="fill nobackground" style="background-image: url(images/traffic.jpg)">
    <hgroup>
        <h2 class="white">Chiaro?</h2>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>... continua...</h3>
    </hgroup>
    <article class="build">
        <p>Threads e  lock, anche se a volte necessari, sono strumenti di basso
            livello.</p>
        <p>In particolare, non possiamo comunque bloccare il thread della ui, in attesa di un mutex</p>
        <p>Ci servono altre primitive</p>
    </article>
</slide>
<slide class="fill nobackground" style="background-image: url(images/atom.jpg)">
    <hgroup>
        <h2 class="white">atomic CAS</h2>
    </hgroup>
</slide>

<slide class="fill nobackground" style="background-image: url(images/nuke.jpg)">
    <hgroup>
        <h2 class="white">....ehr</h2>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Threads</h2>
        <h3>Esempio</h3>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="java">
            private TextView mTv;

            protected void onCreate(Bundle savedInstanceState) {
               //...
               mTv = (TextView)findViewById(...);
               new Thread(){
                 public void run() {
                    final String result = obtainStringFromBlockingSource();
                    // mTv.setText(result); -> Exception ui update from non Main Thread
                    <b>runOnUiThread</b>(new Runnable(){
                        public void run(){
                            mTv.setText(result);
                        }
                    })
                 }
               }.start();
            }
        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Threads</h2>
        <h3>Problemi</h3>
    </hgroup>
    <article class="build">
        <p><span class="red">Leak!</span> Il thread (non statico) contiene un
            riferimento all'activity, il garbage collector non puó eliminarla.
            Rischio di OutOfMemory</p>
        <p>mTv non é piú visibile dopo un cambio di configurazione</p>
        <p>Strategia: bloccare il thread in onDestroy o onStop e riprendere il lavoro in
            onStart()</p>
        <p>Minimizzare il rischio di thread non interruptible, ad esempio timeout,
            controllare InterruptedException</p>
        <p>Minimizzare il rischio di memory leak, disaccoppiando l'activity dal thread: retained
            fragments</p>
        <p>Ancora meglio:</p>
        <p class="red"><b>Non usate i thread nelle activity a meno che non siate sicuri di
            quello che state facendo</b></p>
    </article>
</slide>

<slide class="fill nobackground" style="background-image: url(images/nuke.jpg)">
    <hgroup>
        <h2 class="white">sicuri</h2>
    </hgroup>
</slide>
<slide>
    <hgroup>
        <h2>Soluzioni</h2>
        <h3>AsyncTask</h3>
    </hgroup>
    <article class="build">
    <p>Facilita l'interazione con la ui</p>
    <p>Sconsigliabile per operazioni di lunga durata.</p>
    <p>Non gestisce il cilco di vita delle activity.</p>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
            public class Task extends AsyncTask&lt;Params,Progress,Result&gt;{
                protected void onPreExceute(){/* OPT sul thread della ui prima di essere avviato*/}

                protected Result doInBackground(Params... params){
                    //REQ esegue il lavoro in background
                    publishProgress(Progress...); // invia risultati parziali al thread della ui
                }

                protected void onProgressUpdate(Progress... progress){
                    //OPT callback di publishProgress()
                }
                protected void onPostExecute(Result res){
                    //OPT riceve il valore di ritorno da doInBackground sulla ui
                }
            }
        </pre>
    </article>
    </article>
</slide>
<slide>
    <hgroup>
        <h3>...continua</h3>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
            public AsyncTask execute(Params ... params); //avvia il task

            public final boolean cancel(boolean interrupt); //aborts

            public final boolean isCancelled(); // is aborted

            public void onCancelled(){ } // callback di cancel

        </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>AsyncTask</h2>
        <h3>Valutazione</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>Meglio dei thread</li>
            <li>Leak ancora presenti</li>
            <li>Non usare inner classes non statiche</li>
            <li>Usare weak reference per aiutare il garbage collector</li>
            <li>Cancellare prima di onDestroy</li>
            <li>Disaccopiare dall'activity tramite retained Fragments</li>
        </ul>
    </article>
</slide>

<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>L'engine di Async Task</h3>
    </hgroup>
    <article>
    <p>Async Task sfrutta al suo interno tre componenti basilari di android</p>
    <ul class="build">
        <li><span class="red">Looper:</span> l'astrazione di un ciclo while true associato ad
            un thread</li>
        <li><span class="red">MessageQueue:</span> coda di messaggi associata ad un looper</li>
        <li><span class="red">Handler:</span> gestori di messaggi associati al looper</li>
        <li>Sul main thread gira il looper principale</li>
        <li>Dei tre l'unico che si usa direttamente nel codice utente con una certa frequenza
            é l'handler</li>
    </ul>
    </article>
</slide>

<slide>
    <hgroup><h2>Concorrenza</h2>
        <h3>Handler</h3>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
            private final static int ARG = 1;
            private final static int EVENT_1 = 1;

            public MyHandler extends Handler{
                @Override
                public void handleMessage(Message msg) {
                    switch(msg.what) {
                        case EVENT_1:
                            handleEvent(msg.obj,msg.arg1,msg.arg2);
                            break;
                        //...
                    }
                }
            }

            MyHandler handler = new MyHandler();
            //...

            Message msg =handler.obtainMessage(EVENT_1,ARG,ARG,"ciao");
            handler.sendMessage(msg);
            handler.sendMessageDelayed(handler.obtainEmptyMessage(EVENT_1),1000);
            handler.post(new Runnable(){/*code to execute*/})

            handler.removeMessages(EVENT_1);</pre>
    </article>

</slide>
<slide>
    <hgroup><h2>Concorrenza</h2>
    <h3>Alternative</h3></hgroup>
    <article>
        <p>AsyncQueryHandler</p>
        <p>Wrappa un contentResolver: le operazioni sono effettuate serialmente su un
            looper in background</p>
        <pre class="prettyprint" data-lang="java">
            private final static int QUERY_ID = 1;

            private static class ContentHandler extends AsyncQueryHandler{
                protected void onQueryComplete(int token,Object cookie,Cursor result){
                    // callback
                }
            }
            ContentHandler h = new ContentHandler(getContentResolver());

            h.startQuery(QUERY_ID,/*cookie*/null,uri,....);
        </pre>
    </article>
</slide>
<slide>
    <hgroup><h2>Concorrenza</h2>
    <h3>Alternative</h3></hgroup>
    <article>
        <p>HandlerThread un thread su cui gira un looper</p>
        <pre class="prettyprint" data-lang="java">
            public class MyLoopingThread extends HandlerThread{

                public MyLoopingThread(){
                    super("name for debugging purposes");
                }

                @Override
                protected void onLooperPrepared() {
                    // do some setup before start looping
                }

                public Handler createHandler(Handler.Callback callback){
                    return new Handler(getLooper(),callback);
                }
            }
        </pre>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Loaders</h3>
    </hgroup>
    <article>
        <p>I loader permettono di caricare dati in background in modo sicuro</p>
        <ul class="build">
            <li>Effettuano un task in background (come async task)</li>
            <li>Restituiscono il risultato sul main thread (come async task)</li>
            <li>Continuano ad eseguire il task durante un cambio di configurazione (come
                async task)</li>
            <li><span class="green">Ricordano il loro stato tra una configurazione e l'altra</span></li>
            <li><span class="green">Possono monitorare una sorgente dati (CP) e notificare
                l'activity dei cambiamenti.</span></li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Loaders Continua</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>Presenti dall'api 11</li>
            <li>Usabili con la supprt library dall'api 4</li>
            <li>Non possono essere implementati come classi interne non statiche (policy
                enforced)</li>
            <li>due componenti
                <ul>
                    <li><span class="blue">Loader:</span> che si occupa di fare il lavoro</li>
                    <li><span class="blue">Loader.Callbacks:</span> che vengono notificati
                        dal loader quando l'operazione é conclusa</li>
                    <li>Gestiti tramite LoaderManager</li>
                </ul>
            </li>
            <li>Ci interessa in particolare il CursorLoader</li>
        </ul>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Loaders Continua</h3>
    </hgroup>
    <article class="smaller">
        <p>Gestire e creare i loader</p>
        <pre class="prettyprint" data-lang="java">
                private final static int ID = R.id.LOADER_ID;
                //il loader manager avvia un loader identificato da un id se e solo se non
                //ne esiste giá uno precedente (anche in una configurazione precedente)
                getSupportLoaderManager().initLoader(ID,null,fCallbacks);
                // fCallbacks viene notificato quando il risultato é realizzato

                 //kill currently running loader notify if already completed
                getSupportLoaderManager().destroyLoader(ID);

                // praticamente la somma dei due precedenti
                getSupportLoaderManager().restartLoader(ID,null fCallbacks
            </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Loaders Callbacks</h3>
    </hgroup>
    <article class="smaller">
        <p>Implementare le callback necessarie nell'activity</p>
        <pre class="prettyprint" data-lang="java">

            LoaderManager.LoaderCallbacks&lt;T&gt; fCallbacks =
               new LoaderManager.LoaderCallbacks&lt;T&gt;() {
                 public Loader&lt;T&gt; onCreateLoader(int id, Bundle args) {
                   /* create and return a loader for the id and arguments*/
                   /* cursor loader is the most used tipically we won't need to implement
                      a new one */
                   return new MyLoader(context);
                 }

                 public void onLoadFinished(Loader&lt;T&gt; loader, T data) {
                   /* use loaded data */
                 }

                 public void onLoaderReset(Loader&lt;T&gt; loader) {
                   /* loader has been reset clear data */
                 }
            }
        </pre>
    </article>
</slide>

<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Custom Loaders</h3>
    </hgroup>
    <article class="smaller">
        <p>Implementare un loader custom</p>
        <pre class="prettyprint" data-lang="java">
            public class MyLoader extends AsyncTaskLoader&lt;T&gt;{
              private T mData;

              public MyLoader(Context context) {
                super(context);
              }
              // background work
              @Override public T loadInBackground() {
                T data  = loadYourData();
                return data;
              }
            }
        </pre>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Custom Loaders</h3>
    </hgroup>
    <article class="smaller">
        <p>Implementare un loader custom</p>
        <pre class="prettyprint" data-lang="java">
              // delivers data to onLoadFinished
              @Override public void deliverResult(T data) {
                if(isReset()){
                    // another request overrides the current one
                    releaseYourData(data);
                }
                T old = mData; mData = data;
                if(isStarted()) {
                    // currently active
                    super.deliverResult(mData);
                }
                releaseYourData(old);
              }
              @Override protected void onStartLoading() {
                if(mData!=null) deliverResult(mData); // deliver current results;
                // register watching T changes if possible (calling onContentChanged())
                if(takeContentChanged()||mData==null) {
                    forceLoad();
                }
              }
        </pre>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Concorrenza</h2>
        <h3>Custom Loaders</h3>
    </hgroup>
    <article class="smaller">
        <p>Implementare un loader custom</p>
        <pre class="prettyprint" data-lang="java">
              @Override protected void onStopLoading(){
                cancelLoad();
              }
              @Override public void onCanceled(T data){
                super.onCanceled(data);
                releaseYourData(data);
              }
              @Override public void onReset(){
                super.onReset();
                onStopLoading();
                releaseYourData(mData);
                mData = null;
              }
        </pre>
    </article>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Quarta lezione</h2>
        <h3>Services</h3>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Lavorare in background</h3>
    </hgroup>
    <article>
        <ul class="build">
            <li>Componente che lavora in background</li>
            <li>Usato per operazioni long running</li>
            <li>Non necessita dell'interazione dell'utente</li>
            <li>Modalita' fire and forget, <span class="blue">Started</span> </li>
            <li>Moadalita' client/server, <span class="blue">Bound</span> </li>
            <li>O entrambe!</li>
            <li>I servizi di android sono implementati tramite service</li>
            <li class="red">Il codice viene comunque eseguito sul main thread!!</li>
            <li class="red">Un service potrebbe essere spento dal sistema se gira per troppo tempo</li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Ciclo di vita</h3>
    </hgroup>
    <article class="columns-2">
        <img src="images/service_lifecycle.png"/>
        <ul class="build">
            <li>Molto piu' semplice del ciclo di vita dell'activity</li>
            <li>Apparentemente:</li>
            <li>Le due modalita' si possono usare insieme</li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Modalita' started</h3>
    </hgroup>
    <article>
        <ul class="build">
           <li>Il service viene avviato tramite intent</li>
           <li>L'intent iniziale e' l'unico canale di comunicazione col service</li>
           <li>Resta attivo fino a segnalazione esplicita</li>
           <li>Quando si stoppa il service viene immediatamente distrutto</li>
           <li>Piu' tempo resta attivo piu' aumenta la probabilita' che il sistema lo killi prematuramente</li>
           <li>Siamo noi a decidere in che modo reagire a questo evento</li>
            <li>Se facciamo partire piu' volte un servizio gia' attivo gli intent arrivano sempre allo stesso service</li>
            <li>Nota: onBind va sempre implementato!</li>
        </ul>
    </article>
</slide>


<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Basic implementation</h3>
    </hgroup>
    <article>
        <ul class="build smaller">
                <pre class="prettyprint" data-lang="xml">
                    &lt;service android:name=".MyService"&gt;
                        &lt;intent-filter&gt;
                            &lt;-- .... --&gt;
                        &lt;/intent-filter&gt;
                    &lt;/service&gt;</pre>
            </li>
            <li>
                <pre class="prettyprint" data-lang="java">
                    public class MyService extends Service {
                        @Override public IBinder onBind(Intent intent){
                              return null; // metodo astratto che va sempre implementato
                        }
                        @Override public int onStartCommand(Intent intent,
                                                            int flags,int startId){
                            return START_NOT_STICKY; //start mode
                        }
                    }</pre>
            </li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Basic implementation</h3>
    </hgroup>
    <article>
            <li>
                <pre class="prettyprint" data-lang="java">
                    // avviare un service
                    context.startService(new Intent(context,MyService.class));

                    // stoppare un service started
                    context.stopService(intent);

                    // o dall'interno del service stesso
                    stopSelf(int startId);
                    stopSelf();
                    stopSelfResult(int startId);

                </pre>
            </li>
        </ul>
    </article>
</slide>


<slide>
    <hgroup>
        <h2>Service</h2>
        <h3>Start mode/startFlag/ startId</h3>
    </hgroup>
    <article class="build">
        <ul><li>Start mode determina in che modo far ripartire un service se spento dal sistema</li>
            <li><span class="red">START_NOT_STICKY</span> il service non viene riavviato </li>
            <li><span class="red">START_REDELIVERY_INTENT</span> il service viene riavviato e l'ultimo intent viene ripresentato a startCommand</li>
            <li><span class="red">START_STICKY</span> il service viene riavviato ma l'intent non viene rimandato al service</li>
            <li>Start flag segnala la modalita' di avvio corrente</li>
            <li><span class="green">0</span> nulla da dichiarare avvio normale del service</li>
            <li><span class="green">START_FLAG_RETRY</span> il service e' riavviato perche' l'intent non e' stato processato</li>
            <li><span class="green">START_FLAG_REDELIVERY_INTENT</span> il service e' riavviato con l'intent precedentemente non gestito</li>
            <li>Start id e' l'identificativo univoco della chiamata a startService da usare per stoppare il servizio</li>
        </ul>
    </article>
</slide>


<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Services</h2>
        <h3>Modalita' bounded</h3>
    </hgroup>
    <article>
        <ul>
            <li>Modalita' client server</li>
            <li>Bisogna restituire un IBinder</li>
            <li>Per serivzi locali basta estendere Binder</li>
            <li>Per servizi usabili da remoto bisogna usare un Messenger o AIDL</li>
        </ul>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Services</h2>
        <h3>Modalita' bounded</h3>
    </hgroup>
    <article>
        <pre class="prettyprint" data-lang="java">
            private final ServiceConnection connection =
                new ServiceConnection(){
                public void onServiceConnected(ComponentName name,IBinder binder){
                }
                public void onServiceDisconnected(ComponentName name){}
            };
            //binding
            bindService(intent,connection,/*flags*/Context.BIND_AUTO_CREATE);
        </pre>
    </article>
</slide>
<slide>
    <hgroup><h2>Services Lifecycle</h2>
    </hgroup>
    <article class="flexbox vcenter">
        <img src="images/service_binding_tree_lifecycle.png"/>
    </article>
</slide>
<slide class="segue fill nobackground" style="background-image: url(images/code-session.png)">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2 class="white">CODE</h2>
    </hgroup>
</slide>
<slide>
    <hgroup><h2>Services</h2>
    <h3>IPC</h3></hgroup>
    <article>
        <ul class="build"><li>Android ci permette di mettere in comunicazione app diverse</li>
        <li>Ognuna gira in un proprio processo</li>
        <li>Non possiamo usare Binder in questa situazione</li>
        <li>LocalBinder non é definita nel classloader dell'app client</li>
        <li>Dobbiamo implementare Messenger o definer un'interfaccia AIDL</li>
        <li>AIDL é l'ultima risorsa a cui ricorrere quando nessuna delle altre soluzioni é sufficiente</li></ul>
    </article>

</slide>
<slide>
    <hgroup><h2>Services</h2>
    <h3>Messenger</h3>
    </hgroup>
    <article class="smaller">

            <pre class="prettyprint" data-lang="java">
                public class OneMessengerService extends Service {
                    private static final int MESSAGE_REQUEST =1;
                    private static final int MESSAGE_RESULT = 2;
                    private static final int REALLY_IMPORTANT_ONE = 1;
                    private final Messenger messenger = new Messenger(new HandlerQueue());
                    private class HandlerQueue extends Handler{
                        @Override
                        public void handleMessage(Message msg) {
                            switch (msg.what){
                                case MESSAGE_REQUEST:
                                     Message reply = Message.obtain(null, MESSAGE_RESULT, REALLY_IMPORTANT_ONE);
                                     try {
                                        Messenger remote =msg.replyTo;
                                        remote.send(reply);
                                     } catch (RemoteException e) {
                                        //client disconnected
                                     }
                                break;
                            }
                        }
                    }
                    @Override
                    public IBinder onBind(Intent intent) {
                        return messenger.getBinder();
                    }
                }
            </pre>
    </article>
</slide>
<slide>
    <hgroup>
        <h2>Services</h2>
        <h3>Messenger</h3>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
            public class OneClient extends Activity implements ServiceConnection{
    private Messenger mService;
    private final Messenger mReceiver = new Messenger(new ReceiveHandler());
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
            mService = new Messenger(service);
            Message send = Message.obtain(null,MESSAGE_REQUEST);
            send.replyTo=mReceiver;
            try {
                mService.send(send);
            } catch (RemoteException e) {
                // disconnected
            }
    }
    @Override
    public void onServiceDisconnected(ComponentName name) {
      mService= null;
    }
    class ReceiveHandler extends Handler{
        //...
    }
}</pre>
    </article>
</slide>
<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>Eventi</h2>
        <h3>Broadcast receiver</h3>
    </hgroup>
</slide>
<slide>
    <hgroup><h2>Broadcast Receiver</h2>
    <h3>Introduzione</h3></hgroup>
    <article>
        <ul class="build"><li>Componenti android che permettono di registrarsi ad eventi di sistema o applicativi</li>
            <li>Restano in ascolto anche quando l'app é spenta</li>
            <li>NON sono un context</li>
            <li>Temporanei: registrati da un'activity/service interessati ad un evento</li>
            <li>Possono essere registrati in modo permanente nel manifest</li>
            <li>Nota: per sicurezza l'app deve essere stata accesa almeno una volta prima che un receiver sia realmente attivo</li>
            <li>Allo scadere di un timeout (10 secondi) il receiver viene chiuso dal sistema</li>
        </ul>
    </article>
</slide>
<slide>
    <hgroup><h2>Broadcast Receiver</h2>
    <h3>Receiver globali</h3></hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="xml">
            &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;
            &lt;receiver android:name="BootReceiver" &gt;
                &lt;intent-filter&gt;
                    &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
                &lt;/intent-filter&gt;
            &lt;/receiver&gt;</pre>
        <pre class="prettyprint" data-lang="java">
            public class BootReceiver extends BroadcastReceiver {
                @Override
                public void onReceive(Context context,Intent intent) {
                    if("android.intent.action.BOOT_COMPLETED".equals(intent.getAction())) {
                        context.startService(context,DoActualWorkService.class);
                    }
                }
                //alla fine di onreceive (o allo scadere del timeout) il sistema scarta il receiver
            }</pre>
    </article>
</slide>
<slide>
    <hgroup><h2>Broadcast Receiver</h2>
    <h3>Receiver dinamici</h3></hgroup>
    <article class="smaller">
        <ul class="build"><li>Registrare broadcast receiver appesantisce il sistema</li>
            <li>Gli eventi potrebbero essere interessanti solo in determinate condizioni</li>
            <li>Per questi use case usiamo i receiver dinamici</li>
            <li><pre class="prettyprint" data-lang="java">
                public class BroadcastActivty extends Activity {
    private static final String ACTION = "com.example.intent.BROADCAST";
    private final static IntentFilter filter = new IntentFilter(ACTION);
    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override public void onReceive(Context context, Intent intent) {/*do something useful*/}
    };
    @Override
    protected void onResume() {
        super.onResume();
        registerReceiver(mReceiver,filter);
    }
    @Override
    protected void onPause() {
        unregisterReceiver(mReceiver);
        super.onPause();
    }
    private void send(){
        sendBroadcast(new Intent(ACTION));
    }
}</pre></li>
        </ul>
   </article>
</slide>
<slide>
    <hgroup><h2>Broadcast Receiver</h2>
    <h3>Eventi sticky</h3></hgroup>
    <article class="smaller">
        <ul><li>Una volta che l'evento é stato processato, il sistema lo cancella</li>
        <li>Alcuni usecase richiedono un comportamento diverso, per questo ci sono gli eventi STICKY</li>
        <li>Possiamo registraci o interrogare l'ultimo stato noto dell'evento es batteria/rete</li>
        <li><pre class="prettyprint" data-lang="java">
            IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
            Intent lastKnown = registerReceiver(null/*se l'evento é sticky il receiver é opzionale*/,filter);
            int status = lastKnown.getIntExtra(BatteryManager.EXTRA_LEVEL,-1);
            int scale  = lastKnown.getIntExtra(BatteryManager.EXTRA_SCALE,-1);
            if((status!=-1)&&(scale!=-1)) {
                float charge = levet/(float)scale;
                //reduce resource usage accordingly
            }
        </pre> </li></ul>
    </article>
</slide>

<slide class="segue dark nobackground">
    <aside class="gdbar"><img src="images/google_developers_icon_128.png"></aside>
    <hgroup class="auto-fadein">
        <h2>/system/apps</h2>
        <h3>creare app di sistema</h3>
    </hgroup>
</slide>

<slide>
    <hgroup>
        <h2>Rooting</h2>
        <h3>Abilitare switch user</h3>
    </hgroup>
    <article class="smaller">
        <ul>
            <li>Premessa: adb e fastboot sono tool forniti dall'sdk</li>
            <li>Scaricare un'immagine di recovery: es <a href="https://www.clockworkmod.com/rommanager">
                da qui.
            </a><b>Quella relativa al nostro modello di device</b></li>
            <li>Reboot nel bootloader, <pre>adb reboot bootloader</pre></li>
            <li>Sbloccare bootloader <pre>fastboot oem unlock</pre></li>
            <li>Riavviare: <pre>fastboot reboot</pre></li>
        </ul>
    </article>
</slide>


<slide>
    <hgroup>
        <h2>Rooting</h2>
        <h3>Abilitare switch user</h3>
    </hgroup>
    <article class="smaller">
        <ul>
            <li>Riavviare nel bootloader: <pre>adb reboot bootloader</pre></li>
            <li>Arrivati nel bootloader tentiamo il boot dalla rom scaricata</li>
            <li><pre>fastboot boot recovery-name</pre></li>
            <li>Quando il device sará acceso in recovery abbiamo accesso ad adb e fino al riavvio siamo root</li>
        </ul>
    </article>
</slide>


<slide>
    <hgroup>
        <h2>System Apps</h2>
        <h3>Install/move apk</h3>
    </hgroup>
    <article class="smaller">
        <ul class="build">
           <li>L'apk deve essere sul device</li>
            <li>Se non l'abbiamo installata dobbiamo spostarla manualmente <pre>adb push nomeapk.apk /sdcard/nomeapk.apk</pre></li>
            <li>Entriamo come root</li>
            <li><pre>abd shell</pre> accende la shell</li>
            <li><pre>su</pre> accediamo come root</li>
        </ul>
    </article>
</slide>


<slide>
    <hgroup>
        <h2>System Apps</h2>
        <h3>Install/move apk</h3>
    </hgroup>
    <article class="smaller">
        <ul class="build">

            <li>montiamo la partizione di sistema in modalita RW<pre>mount -o rw,remount /system</pre></li>
            <li>spostiamo l'apk tra le app di sistema: <pre>cp percorsoapk /system/app/nomeapk.apk</pre></li>
            <li>riavviamo il device normalmente</li>
        </ul>
    </article>
</slide>

<slide>
    <hgroup>
        <h2>Reset lock</h2>
    </hgroup>
    <article>
        <ul class="build">
            <li>Opzionale</li>
            <li><pre>adb reboot bootloader</pre></li>
            <li><pre>fastboot oem lock</pre></li>
            <li><pre>fastboot reboot</pre></li>
        </ul>
    </article>
</slide>


<!--

<slide class="segue dark quote nobackground">
  <aside class="gdbar right bottom"><img src="images/google_developers_icon_128.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <q>
      This is an example of quote text.
    </q>
    <div class="author">
      Name<br>
      Company
    </div>
  </article>
</slide>
-->
 
  <!--
  <slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/google_developers_icon_128.png"></aside>
    <article class="flexbox vleft auto-fadein">
      <h2>&lt;Thank You!&gt;</h2>
      <p>Important contact information goes here.</p>
    </article>
    <p class="auto-fadein" data-config-contact>
    </p>
  </slide>

  <slide class="logoslide dark nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/google_developers_logo_white.png"></span>
    </article>
  </slide>
  -->
  <slide class="backdrop"></slide>

</slides>

<!--<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
-->
<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
